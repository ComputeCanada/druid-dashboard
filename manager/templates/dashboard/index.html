{% extends 'base.html' %}

{# --------------------------------------------------------------------------
                                                              EXTRA CSS, JS
-------------------------------------------------------------------------- #}

{% block extra %}
  <script src="{{ url_for('static', filename='misc.js') }}"></script>
  <script src="{{ url_for('static', filename='alerts.js') }}"></script>
  {# ---- Disabling, but will want to consider at some point
  <script src="{{ url_for('static', filename='notifications.js') }}"></script>
  ----- #}
{% endblock %}

{# --------------------------------------------------------------------------
                                                                  SCRIPTAGE
-------------------------------------------------------------------------- #}

{% block scriptage %}
  <script>

// need the report specifications to create tables and interpret data
var report_specs = {{ reports|tojson|safe }};

// for lookup for cluster names
var cluster_lookup = {};

// get user preferences
/* prefs:
 *   cluster: graham
 *   clusters:
 *     graham:
 *       expanded: job age
 *       sorting:
 *         bursts: [3, 'desc']
 *         job age: [4, 'desc']
 *     cedar:
 *       expanded: bursts
 *       sorting:
 *         bursts: [3, 'desc']
 */
var prefsJSON = Cookies.get("prefs");
var prefs = null;
if (prefsJSON) {
  prefs = JSON.parse(prefsJSON);
}

// translation lookup map.  This is to make the text available to library
// code that doesn't get parsed as templates.
var i18n_texts = {
  "Cancel": "{{ _('Cancel') }}",
  "Update": "{{ _('Update') }}"
};

$("#notification").hide();
$("#error").hide();
$("#error").click(function(e) {
  $("#error").hide();
});

function initializePreferences(clusters) {
  /* prefs:
   *   cluster: graham
   *   clusters:
   *     graham:
   *       expanded: job age
   *       sorting:
   *         bursts: [3, 'desc']
   *         job age: [4, 'desc']
   *     cedar:
   *       expanded: bursts
   *       sorting:
   *         bursts: [3, 'desc']
   */
  if (prefs) {
    return;
  }

  prefs = {
    'cluster': clusters[0]['id'],
    'clusters': {}
  };

  clusters.forEach(function(x) {
      prefs['clusters'][x['id']] = x;
    });

  // add each report to sorting list for each cluster
  Object.keys(report_specs).forEach(function(report_name, i1, a1) {

    var report = report_specs[report_name];

    // by default sort descending on the trouble metric
    var troubleIdx = report['cols'].findIndex(function(x) {
      return report['metric'] == x['datum'];
    });
    //Object.keys(prefs['clusters']).forEach(function(cluster_name, i2, a2) {
    //  cluster = prefs['clusters'][cluster_name];
    for (const cluster of Object.values(prefs['clusters'])) {
      if (! cluster['sorting']) {
        cluster['sorting'] = {};
      }
      cluster['sorting'][report_name] = [troubleIdx, 'desc'];
    }
  });

  // we don't write the prefs to cookie yet because it'll get updated by other
  // stuff shortly
}

function updatePreferences() {
  var prefsJSON = JSON.stringify(prefs);
  Cookies.set('prefs', prefsJSON);
}

function requestClusters() {
  status_id = status("Retrieving cluster info...")
  $.ajax({
    url: '/xhr/clusters/',
    method: 'GET',
    success: function(clusters, status, jqXHR) {
      status_clear(status_id);
      displayClusters(clusters, status, jqXHR);
    },
    error: function() {
      status_clear(status_id);
      error("Failed to retrieve cluster list");
    }
  });
}

function displayClusters(clusters, stats, jqXHR) {
  // sort cluster list by proper name
  var clusters_sorted = clusters.sort(function(a, b) {
    return a['name'].localeCompare(b['name']);
  });

  // create cluster lookup
  clusters.forEach(function(cluster) {
    cluster_lookup[cluster['id']] = cluster['name'];
  });

  // initialize preferences
  initializePreferences(clusters_sorted);

  // get tab parent containers
  var tabsContainer = document.getElementById('tabs_container');
  var panesContainer = document.getElementById('panes_container');

  // create tabs for each cluster and add to parent container
  for (var i=0; i < clusters_sorted.length; i++) {
    var cluster = clusters_sorted[i];
    var cluster_id = cluster['id'];
    var cluster_name = cluster['name'];

    var tab_id = cluster_id + '-tab';
    var pane_id = cluster_id + '-pane';

    // add cluster tab
    var tab = document.createElement('li');
    tab.className = 'nav-item';
    tab.setAttribute('role', 'presentation');
    tab.innerHTML = `
      <button class='nav-link' id='${tab_id}' data-bs-toggle='tab'
        data-bs-target='#${pane_id}' role='tab'
        aria-controls='${cluster_id}' aria-selected='false'
      >${cluster_name}</button>`;
    tabsContainer.appendChild(tab);

    // add cluster pane
    var pane = document.createElement('div');
    pane.className = 'tab-pane fade';
    pane.setAttribute('id', pane_id);
    pane.setAttribute('role', 'tabpanel');
    pane.setAttribute('aria-labelled-by', tab_id);
    pane.innerHTML = `
      <div class='accordion' id='${cluster_id}_accordions'>
      </div>`;
    panesContainer.appendChild(pane);
  }

  // display cluster tab from preferences
  activeCluster = prefs['cluster'];

  var activeTabId = `${activeCluster}-tab`;
  var activeTab = document.getElementById(activeTabId);
  activeTab.classList.add('active');
  activeTab.setAttribute('aria-selected', 'true');

  var activePaneId = `${activeCluster}-pane`;
  console.log(`activePaneId = ${activePaneId}`);
  var activePane = document.getElementById(activePaneId);
  activePane.classList.add('show');
  activePane.classList.add('active');

  requestReports(activeCluster);
}


function requestReports(cluster) {
  status_id = status(`Retrieving reports for ${cluster_lookup[cluster]}...`);
  $.ajax({
    url: `/xhr/reports/?cluster=${cluster}`,
    method: 'GET',
    success: function(reports, status, jqXHR) {
      status_clear(status_id);
      displayReports(reports, status, jqXHR);
    },
    error: function() {
      status_clear(status_id);
      error("Failed to retrieve burst reports");
    }
  });
}

function makeTableBlank(cluster, report) {
  var header = `
            <table id='${report}_table_${cluster}' class='bursts' style='width: 100%'>
              <thead>`;
  var rows = "";
  report_specs[report].cols.forEach(function(value, index, array) {
    var classes = "";
    if (!value['searchable']) {
      classes += " nosearch";
    }
    if (!value['sortable']) {
      classes += " nosort";
    }
    if (value['type'] == "number") {
      classes += " number";
    }
    rows += `
                  <th class='${ classes }'>${ value['title'] }</th>`;
  });

  return header + rows + `
                  <th>{{ _('State') }}</th>
                  <th>{{ _('Analyst') }}</th>
                  <th>{{ _('Ticket') }}</th>
                  <th class='number'>{{ _('Notes') }}</th>
                  <th class='nosearch nosort'>{{ _('Action') }}</th>
                </tr>
              </thead>
              <tbody>
              </tbody>
            </table>
  `;
}


function displayReports(reports, status, jqXHR) {

  // we don't go by active tab in case there's a race condition
  var cluster = reports['cluster'];

  // get main accordion container
  var accordionParent = document.getElementById(`${cluster}_accordions`);

  // get just reports by filtering out 'cluster'
  var report_names = Object.keys(reports).filter(function(item) {
    return item !== 'cluster'
  });

  // check if there are reports
  if (report_names.length == 0) {
    accordionParent.innerHTML = "<p>{{ _('There are currently no bursts defined.') }}</p>";
  }
  else {
    for (var i=0; i < report_names.length; i++) {

      var report = report_names[i];

      // TODO: i18n
      var title = `${report} - reported ${epoch_to_local_time(reports[report]['epoch'])}`;

      // create accordian for this
      var accordion = document.createElement('div');
      accordion.innerHTML = `<div class="accordion-item">
        <h2 class="accordion-header" id="heading-${cluster}-${report}">
          <button id="collapse-button-${cluster}-${report}"
            class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
            data-bs-target="#collapse-${cluster}-${report}" aria-expanded="false"
            aria-controls="collapse-${cluster}-${report}"
          >
            ${title}
          </button>
        </h2>
        <div id="collapse-${cluster}-${report}" class="accordion-collapse collapse"
          aria-labelledby="heading-${cluster}-${report}" data-bs-parent="#${cluster}_accordions"
          data-ccf-report='${report}' data-ccf-cluster='${cluster}'
        >
          <div class="accordion-body">
            ${makeTableBlank(cluster, "bursts")}
          </div>
        </div>
      </div>`;

      // add to parent and so to the DOM
      accordionParent.appendChild(accordion);

      // create the table
      // TODO: use `prefs` instead of `ordering`
      populateReportTable(cluster, report, reports[report]['results'], [[3, 'desc']]);

      // set up ordering update handler
      // TODO: use `prefs` instead of `ordering`
      $(`#${report}_table_${cluster}`).on('order.dt', function(event) {
        var order = $(event.target).DataTable().order();
        Cookies.set("ordering", JSON.stringify(order));
      });

    }

    // determine which report should be expanded by default
    var expanded = prefs['clusters'][cluster]['expanded'];
    if (!expanded || report_names.indexOf(expanded) == -1) {
      error(`Resetting preferred report because report ${expanded} does not exist for cluster ${cluster_lookup[cluster]}`);
      expanded = report_names[0];
      prefs['clusters'][cluster]['expanded'] = expanded;
      updatePreferences();
    }

    // expand that cluster's accordion
    // There are two ways to do this: send a button-click message to the
    // accordion button, or manipulate the classes of the accordion button
    // and the accordioned division.  The latter eliminates the animation,
    // which is too much fancy for a basic page load
    //$(`#collapse-button-${expanded}`).click();
    $(`#collapse-button-${cluster}-${expanded}`).removeClass('collapsed');
    $(`#collapse-${cluster}-${expanded}`).addClass('show');

    // add listener for saving user's preference
    accordionParent.addEventListener('show.bs.collapse', function(event) {
      var thisCluster = event.target.dataset.ccfCluster;
      var defaultReport = event.target.dataset.ccfReport;
      prefs['clusters'][thisCluster]['expanded'] = defaultReport;
      updatePreferences();
    });
  }
}

function refreshBursts(reports, status, jqXHR) {

  /* TODO: should be "refreshReports"
   * This should check whether there are additional clusters and/or reports
   * than existed previously by checking contents of prefs, and if updates
   * do not match what's there, create default prefs for new stuff, and update
   * UI components to match changes (add and remove cluster tabs; add and
   * remove report accordions)
   */

  /* TODO: DRY.  This is very "wet" */

  // burst reports are organized by cluster
  if (Object.keys(reports).length == 0) {
    //TODO: remove accordions and data tables and paste a message of some kind
  }
  else {

    // get ordering
    // TODO: use `prefs` instead of `ordering`
    var orderingJSON = Cookies.get("ordering");
    if (orderingJSON) {
      var ordering = JSON.parse(orderingJSON);
    } else {
      var ordering = [[3, 'desc']];
    }

    for (var cluster in reports) {

      // clear out the accordion
      $(`#collapse-${cluster}-${report}`).html(`
          <div class="accordion-body">
            ${makeTableBlank(cluster)}
          </div>`);

      // create the table
      // TODO: use `prefs` instead of `ordering`
      populateReportTable(cluster, report, reports[cluster], ordering);
    }
  }
}

function populateReportTable(cluster, report, data, ordering) {
  console.log("In populateReportTable().  Cluster: " + cluster + ", report: " + report);
  console.log("Preferences:");
  console.log(prefs);

  // build array of column definitions of the format {"name": name}
  var columnNames = report_specs[report]['cols'].map(function(x) {
    return { "name": x['datum'] };
  }).concat([
    { "name": "state" },
    { "name": "analyst" },
    { "name": "ticket" },
    { "name": "notes" },
    { "name": "action" },
    { "name": "id" },
  ]);
  var idRowIdx = columnNames.length - 1;

  $(`#${report}_table_${cluster}`).dataTable({
    "autoWidth": false,
    "data": renderTableData(data),
    "columnDefs": [
      { searchable: false, targets: 'nosearch' },
      { orderable: false, targets: 'nosort' },
      { className: 'number', targets: 'number' },
      { visible: false, targets: [idRowIdx] }
    ],
    columns: columnNames,
    // TODO: use `prefs` instead of `ordering`
    order: prefs['clusters'][cluster]['sorting'][report],
    rowId: function(row) { return "burst_" + row[idRowIdx] }
  });
}

function updateTicket(ticket, status, jqXHR) {
  var el_id = `#ticket_${ticket.burst_id}`;
  var href = `<a href='${ticket.url}' target='_ticket'>${ticket.ticket_no}</a>`;
  $(el_id).html(href);
}

function showTicketComposition(template, burst_id, account_id) {

  var modalEl = document.getElementById('ticketCompositionModal');

  // reset form
  var modalForm = modalEl.querySelector('.modal-form');
  modalForm.reset();
  modalForm.action = `javascript:createTicket(${burst_id}, '${template.recipient}', '${template.email}')`;

  // populate form
  var titleEl = document.getElementById('ticketCreationTitle');
  titleEl.value = template.title;
  var bodyEl = document.getElementById('ticketCreationText');
  bodyEl.value = template.body;

  // override reset button
  var resetEl = document.getElementById('ticketCompositionReset');
  resetEl.addEventListener('click', function() {
    console.log("Clicked on resetEl");
    titleEl.value = template.title;
    bodyEl.value = template.body;
  });

  // show modal
  var modal = bootstrap.Modal.getInstance(modalEl);
  modal.show();
}

// ticket creation, step 1: trigger composition
function triggerTicketComposition(id, account) {

  // close "create ticket" modal
  var myModal = bootstrap.Modal.getInstance(document.getElementById('ticketCreationModal'));
  myModal.hide();

  // get ticket type
  var ticket_type = $('#outreach-type')[0].value;

  // determine URL
  var url = `/xhr/templates/${ticket_type}?burst_id=${id}`;

  // add recipient if appropriate
  if (recipientSelectable(ticket_type)) {
    var recipient = $('#ticketRecipient')[0].value;
    url += `&recipient=${recipient}`;
  }

  // load template and then launch ticket composition modal
  status_id = status("Retrieving template...")
  $.ajax({
    url: url,
    method: 'GET',
    success: function(template, status, jqXHR) {
      status_clear(status_id);
      showTicketComposition(template, id, account);
    },
    error: function() {
      status_clear(status_id);
      error(`Unable to retrieve template of type ${ticket_type}`);
    }
  });
}

// step 2: actually creating the ticket
function createTicket(id, recipient, email) {

  status_id = status(`Creating ticket for user ${recipient}...`);

  // get form data
  var titleEl = document.getElementById('ticketCreationTitle');
  var title = titleEl.value;
  var bodyEl = document.getElementById('ticketCreationText');
  var body = bodyEl.value;

  // post the ticket creation
  $.ajax({
    url: '/xhr/tickets/',
    method: 'POST',
    data: {
      burst_id: id,
      recipient: recipient,
      email: email,
      title: title,
      body: body
    },
    success: function(ticket, status, jqXHR) {
      status_clear(status_id);

      // close modal
      var myModal = bootstrap.Modal.getInstance(document.getElementById('ticketCompositionModal'));
      myModal.hide();

      updateTicket(ticket, status, jqXHR);
    },
    error: function() {
      status_clear(status_id);
      error("Creation of ticket failed");
    }
  });
}

function updateBursts(updates, options = {
    action: "Updating...",
    error: "Failed to update"
  }) {

  // close modal
  var myModal = bootstrap.Modal.getInstance(document.getElementById('noteModal'));
  myModal.hide();

  status_id = status(options.action);
  // make request
  $.ajax({
    url: '/xhr/bursts/',
    method: 'PATCH',
    data: JSON.stringify(updates),
    contentType: 'application/json',
    success: function(reports, status, jqXHR) {
      status_clear(status_id);
      refreshBursts(reports, status, jqXHR);
    },
    error: function() {
      status_clear(status_id);
      error(options.error);
    }
  });
}

function createNote(id, account) {

  // set up update request
  var updates = [
    {
      'id': id,
      'note': $('#noteModalTextarea')[0].value
    }
  ];

  // process update
  updateBursts(updates, {
    action: "Creating note for candidate...",
    error: "Failed to create note"
  });
}

function stealBurst(id, account) {

  // set up update request.  'claimant' is set to blank string so it's filled
  // in with logged-in user on server side
  var updates = [
    {
      'id': id,
      'claimant': '',
      'note': $('#noteModalTextarea')[0].value
    }
  ]

  // process update
  updateBursts(updates, {
    action: "Stealing burst candidate...",
    error: "Failed to steal burst candidate"
  });
}

function claimBurst(id, account) {

  // set up update request.  'claimant' is set to blank string so it's filled
  // in with logged-in user on server side
  var updates = [
    {
      'id': id,
      'claimant': '',
      'note': $('#noteModalTextarea')[0].value
    }
  ]

  // process update
  updateBursts(updates, {
    action: "Claiming burst candidate...",
    error: "Failed to claim burst candidate"
  });
}

function releaseBurst(id, account) {

  // set up update request
  var updates = [
    {
      'id': id,
      'claimant': null,
      'note': $('#noteModalTextarea')[0].value
    }
  ]

  // process update
  updateBursts(updates, {
    action: "Releasing burst candidate...",
    error: "Failed to claim candidate"
  });
}

function rejectBurst(id, account) {

  // set up update request.  'claimant' is set to blank string so it's filled
  // in with logged-in user on server side
  var updates = [
    {
      'id': id,
      'state': 'rejected',
      'note': $('#noteModalTextarea')[0].value
    }
  ]

  // process update
  updateBursts(updates, {
    action: "Rejecting burst candidate...",
    error: "Failed to reject candidate"
  });
}

function acceptBurst(id, account) {

  // set up update request.  'claimant' is set to blank string so it's filled
  // in with logged-in user on server side
  var updates = [
    {
      'id': id,
      'state': 'accepted',
      'note': $('#noteModalTextarea')[0].value
    }
  ]

  // process update
  updateBursts(updates, {
    action: "Accepting burst candidate...",
    error: "Failed to accept candidate"
  });
}

// find first row in a table
function find_first_row(tbody_id) {
  var el = document.getElementById(tbody_id);
  if (el.nodeName == "TBODY") {
    el = el.firstElementChild;
    if (el.nodeName == "TR") {
      return(el);
    }
  }
  return null;
}


function eventsToHtml(events) {
  var html = '';
  var title;
  var details;

  if (events.length == 0) {
    return "<p>No events recorded for this burst candidate.</p>";
  }

  for (var i=0, ien=events.length; i<ien; i++) {
    details = '';
    event = events[i];
    switch (event.type) {
      case "Note":
        title = 'Note';
        break;
      case "ClaimantUpdate":
        title = 'Claimant update';
        if (!event.claimant_was_pretty) {
          details = `Claimed by ${event.claimant_now_pretty}`;
        }
        else {
          details = `Stolen by ${event.claimant_now_pretty} from ${event.claimant_was_pretty}`;
        }
        break;
      case "StateUpdate":
        title = 'State update';
        details = `From ${event.old_state} to ${event.new_state}`;
        break;
      default:
        title = `Unknown type of event (${event.type})`;
        details = '<dl>';
        for (key in event) {
          details += `<dt>${key}</dt><dd>${event[key]}</dd>`;
        }
        details += '</dl>';
        break;
    }
    html += `<h6>${title} by ${event.analyst_pretty}, ${timestamp_to_local_time(event.timestamp)}</h6>`;
    if (details) {
      html += `<p>${details}</p>`;
    }
    if (event.text) {
      html += `<p>${event.text.split('\n\n').join("</p><p>")}</p>`;
    }
  }
  return html;
}


function showBurstHistory(burstID) {
  // show status
  status_id = status("Retrieving events...");

  $.ajax({
    url: `/xhr/bursts/${burstID}/events/`,
    method: 'GET',
    success: function(events, status, jqXHR) {
      status_clear(status_id);

      // set history content
      var modalBodyEl = document.getElementById('historyModalBody');
      modalBodyEl.innerHTML = eventsToHtml(events);

      // show modal
      var modalEl = document.getElementById('historyModal');
      var modal = bootstrap.Modal.getInstance(modalEl);
      modal.show();
    },
    error: function() {
      status_clear(status_id);
      error("Failed to retrieve burst events");
    }
  });
}


function jsonToTable(json) {
  var summary = JSON.parse(json);
  var summaryHTML = '';
  for (key in summary) {
    if (key == "old_pain") {
      value = summary[key].toFixed(2);
    }
    else {
      value = summary[key];
    }
    summaryHTML += `<tr><th>${key}</th><td>${value}</td></tr>`;
  }
  return `<table class='not-table'>${summaryHTML}</table>`;

}

function renderActionMenu(burst) {

  function makeActionButton(burstID, account, action, target, label) {
    return `
        <li><button class='dropdown-item' type='button' id='action_${action}_${burstID}'
              data-bs-toggle='modal' data-bs-target='${target}'
              data-burst-id='${burstID}' data-account-id='${account}'
              data-action='${action}'
            >${label}</button></li>`;
  }

  function makeButton(burstID, account, target, label) {
    return `
        <li><button class='dropdown-item' type='button'
              data-bs-toggle='modal' data-bs-target='${target}'
              data-burst-id='${burstID}' data-account-id='${account}'
            >${label}</button></li>`;
  }

  // "History" menu item
  var items = makeActionButton(burst.id, burst.account, 'history', '#historyModal', 'History');

  // "Claim" menu item
  // only available if no claimant
  if (!burst.claimant) {
    items += makeActionButton(burst.id, burst.account, 'claim', '#noteModal', 'Claim');
  }
  else {
    if (burst.claimant != "{{ session['cci'] }}") {
      items += makeActionButton(burst.id, burst.account, 'steal', '#noteModal', 'Steal');
    }
    else {
      items += makeActionButton(burst.id, burst.account, 'release', '#noteModal', 'Release');
    }
  }

  // "Create ticket" menu item
  // only available if no ticket already associated
  if (!burst.ticket_href) {
    items += makeButton(burst.id, burst.account, '#ticketCreationModal', 'Create ticket');
  }

  // "Make note" menu item
  items += makeActionButton(burst.id, burst.account, 'note', '#noteModal', 'Make note');

  // "Reject" menu item
  // only available if state is pending
  if (burst.state == 'pending') {
    items += makeActionButton(burst.id, burst.account, 'reject', '#noteModal', 'Reject');
  }

  // "Accept" menu item
  // only available if state is pending and there is an associated ticket
  if (burst.state == 'pending' && burst.ticket_id) {
    items += makeActionButton(burst.id, burst.account, 'accept', '#noteModal', 'Accept');
  }

  return `
    <div class='dropdown'>
      <button class='btn btn-secondary dropdown-toggle' type='button' id='actionMenuButton_${burst.id}' data-bs-toggle='dropdown'>
        {{ _("Action") }}
      </button>
      <ul class='dropdown-menu'>${ items }
      </ul>
    </div>`;
}

function renderTableData(bursts) {

  var id, account, resource;

  bycols = [];
  for (var i=0, ien=bursts.length; i<ien; i++) {

    id = bursts[i].id;
    account = bursts[i].account;
    resource = bursts[i].resource;

    bycols[i] = [
      bursts[i].ticks,
      bursts[i].account,
      `<a target="beamplot" href="https://static.frak.c3.ca/usage-graphs/${account}_${resource}_cumu_plot.html">Cumulative</a><br/>
       <a target="beamplot" href="https://static.frak.c3.ca/usage-graphs/${account}_${resource}_insta_plot.html">Instant</a>`,
      bursts[i].pain.toFixed(2),
      jsonToTable(bursts[i].summary),
      bursts[i].state_pretty,
      bursts[i].claimant_pretty || "-",
      `<span id='ticket_${id}' data-burst-id='${id}'>${ bursts[i].ticket_href || "-" }</span>`,
      bursts[i].other['notes'],
      renderActionMenu(bursts[i]),
      id
    ];
  }

  return bycols;
}

function recipientSelectable(outreach) {
  console.log("Evaluating outreach type: " + outreach);
  switch (outreach) {
    case "impossible":
    case "empty":
      return true;
      break;
  }
  return false;
}

$(document).ready(function() {

  // retrieve clusters
  requestClusters();

  // initialize the create-ticket modal
  var createTicketModal = document.getElementById('ticketCreationModal');
  createTicketModal.addEventListener('show.bs.modal', function (event) {
    // button that triggered the modal
    var button = event.relatedTarget;

    // extra information about button
    var burst_id = button.getAttribute('data-burst-id');
    var account_id = button.getAttribute('data-account-id');

    // by default hide the recipient selector
    var recipientSelector = document.getElementById('recipientSelector');
    recipientSelector.style.display = 'none';

    // show status
    status_id = status("Retrieving burst info...");

    // get recipient selection element
    var recipients = $('#ticketRecipient');
    recipients.empty();

    $.ajax({
      url: `/xhr/bursts/${burst_id}/people/`,
      method: 'GET',
      success: function(people, status, jqXHR) {
        status_clear(status_id);

        // create recipient list, starting with PI as default
        var pi = people.pi;
        recipients.append(`<option value='${pi}' selected>${pi} (PI)</option>`);
        for (var i=0; i<people.submitters.length; i++) {
          var submitter = people.submitters[i];
          if (pi != submitter) {
            recipients.append(`<option value='${submitter}'>${submitter}</option>`);
          }
        }
      },
      error: function() {
        status_clear(status_id);
        error("Failed to retrieve burst info");
      }
    });

    // update modal
    var modalForm = createTicketModal.querySelector('.modal-form');
    modalForm.reset();
    modalForm.action = `javascript:triggerTicketComposition(${burst_id}, '${account_id}')`;
  });

  // initialize the choose-a-template selection
  var templateSelector = document.getElementById('outreach-type');
  templateSelector.addEventListener('change', function(event) {
    // get the recipient selector
    var recipientSelector = document.getElementById('recipientSelector');
    if (recipientSelectable(event.target.value)) {
      // show recipient selection
      recipientSelector.style.display = 'block';
    }
    else {
      // hide recipient selection
      recipientSelector.style.display = 'none';
    }
  });

  // initialize the compose-ticket modal.  Set to ignore Escape
  var ticketCompositionModalEl = document.getElementById('ticketCompositionModal');
  var ticketCompositionModal = new bootstrap.Modal(ticketCompositionModalEl, {
    keyboard: false
  });

  var noteModal = document.getElementById('noteModal');
  noteModal.addEventListener('show.bs.modal', function(event) {

    function initModal({
      title,
      intro,
      textareaLabel = 'Note',
      textareaRequired = false,
      cancel = "Cancel",
      submit = "Submit"
    }) {
      document.getElementById('noteModalTitle').innerText = title;
      document.getElementById('noteModalIntro').innerText = intro;
      document.getElementById('noteModalTextareaLabel').innerText = textareaLabel;
      document.getElementById('noteModalCancel').innerText = cancel;
      document.getElementById('noteModalSubmit').innerText = submit;
      document.getElementById('noteModalTextarea').required = textareaRequired;
    }

    // button that triggered the modal
    var button = event.relatedTarget;

    // extra information about button
    var burst_id = button.getAttribute('data-burst-id');
    var account_id = button.getAttribute('data-account-id');
    var action = button.getAttribute('data-action');

    // set up modal
    switch (action) {
      case "steal":
        initModal({
          title: 'Steal',
          intro: 'By stealing this burst candidate you indicate you will follow \
                  up with the analysis of this job set and with the research \
                  group, as necessary.',
          textareaRequired: true,
          submit: 'Steal'});
        fn = 'stealBurst';
        break;
      case "claim":
        initModal({
          title: 'Claim',
          intro: 'By claiming this burst you indicate you will follow up with \
                  the analysis of this job set and with the research group, as \
                  necessary.',
          submit: 'Claim'});
        fn = 'claimBurst';
        break;
      case "release":
        initModal({
          title: 'Release',
          intro: 'Release the burst candidate so that another analyst knows to\
                  look into it or contact the researcher for followup.',
          submit: 'Release'});
        fn = 'releaseBurst';
        break;
      case 'reject':
        initModal({
          title: 'Reject',
          intro: "By rejecting this burst candidate you are indicating it's not \
                  of interest for bursting.",
          textareaRequired: true,
          submit: 'Reject'});
        fn = 'rejectBurst';
        break;
      case 'accept':
        initModal({
          title: 'Accept',
          intro: 'By accepting this burst candidate you are confirming this \
                  account is eligible for elevated access to resources.',
          submit: 'Accept'});
        fn = 'acceptBurst';
        break;
      case 'note':
        initModal({
          title: 'Note',
          intro: 'This note will become part of the burst candidate history.',
          textareaRequired: true,
          submit: 'Note'});
        fn = 'createNote';
        break;
    }

    // update modal
    var modalForm = noteModal.querySelector('.modal-form');
    modalForm.reset();
    modalForm.action = `javascript:${fn}(${burst_id}, '${account_id}')`;
  });

  var historyModal = document.getElementById('historyModal');
  historyModal.addEventListener('show.bs.modal', function (event) {
    // button that triggered the modal
    var button = event.relatedTarget;

    // extra information about button
    var burst_id = button.getAttribute('data-burst-id');

    // clear body
    var modalBodyEl = document.getElementById('historyModalBody');
    modalBodyEl.innerHTML = "<p><i>Loading history...</i></p>";

    // update modal
    showBurstHistory(burst_id);
  });

});
  </script>
{% endblock %}

{# --------------------------------------------------------------------------
                                                                     HEADER
-------------------------------------------------------------------------- #}
{% block title %}{{ _('Dashboard') }}{% endblock %}
{% block header %}
  <h1>Burst reports</h1>
{% endblock %}

{# --------------------------------------------------------------------------
                                                                    CONTENT
-------------------------------------------------------------------------- #}

{% block content %}
<div id='notification'>
</div>
<div id='error'>
</div>

<ul class='nav nav-tabs' id='tabs_container' role='tablist'>
</ul>
<div class='tab-content' id='panes_container'>
</div>

{# --------------------------------------------------------------------------
                                                     TICKET CREATION MODALS
-------------------------------------------------------------------------- #}

<div class='modal modal.draggable fade' id='ticketCreationModal' tabindex='-1'>
  <div class='modal-dialog modal-dialog-centered'>
    <div class='modal-content'>
      <form class='modal-form'>
        <div class='modal-header'>
          <h5 class='modal-title' id='ticketCreationModalLabel'>Create ticket: Select template</h5>
          <button type='button' class='btn-close' data-bs-dismiss='modal'></button>
        </div>

        <div class='modal-body'>

          <p>Some types of outreach allow specification of a recipient other
          than the account's PI, based on those submitting jobs to this account.</p>

          <p>
            <label for='outreach-type'>Select what sort of outreach you want to initiate:</label>
            <select class='form-select' id='outreach-type' required>
              <option selected disabled value=''>Choose outreach type</option>
              <option value='candidate'>Burst candidate</option>
              <option value='impossible'>Impossible jobs</option>
              <option value='rac'>Apply for RAC</option>
              <option value='empty'>Empty</option>
            </select>
          </p>

          <p id='recipientSelector'>
            <label for='recipient'>Select recipient:</label>
            <select class='form-select' id='ticketRecipient'>
            </select>
          </p>

        </div>

        <div class='modal-footer'>
          <button type='button' class='btn btn-secondary' data-bs-dismiss='modal'>Cancel</button>
          <button type='submit' class='btn btn-primary'>Compose</button>
        </div>

      </form>
    </div>
  </div>
</div>

<div class='modal fade' id='ticketCompositionModal' tabindex='-1'>
  <div class='modal-dialog modal-dialog-centered'>
    <div class='modal-content'>
      <form class='modal-form'>
        <div class='modal-header'>
          <h5 class='modal-title' id='ticketCompositionModalLabel'>Create ticket: Compose message</h5>
          <button type='button' class='btn-close' data-bs-dismiss='modal'></button>
        </div>
        <div class='modal-body'>
          <p><strong>Note</strong>: Continuing with this operation will create a ticket and send an outgoing e-mail to the PI associated with this account, or another recipient as selected.</p>

          <div class='form-group'>
            <label for='ticketCreationTitle' id='ticketCreationTitleLabel'>Title</label>
            <input class='form-control' type='text' id='ticketCreationTitle' required></input>

            <label for='ticketCreationText' id='ticketCreationTextLabel'>Body</label>
            <textarea class='form-control' type='text' id='ticketCreationText' required rows='3'></textarea>
          </div>

          <div class='form-check'>
            <input class='form-check-input' type='checkbox' value='' id='agreeEmail' unchecked required>
            <label class='form-check-label' for='agreeEmail'>
              Agree to send e-mails
            </label>
          </div>

        </div>
        <div class='modal-footer'>
          <button type='button' class='btn btn-secondary' data-bs-dismiss='modal'>Cancel</button>
          <button type='button' id='ticketCompositionReset' class='btn btn-secondary'>Revert</button>
          <button type='submit' class='btn btn-primary'>Create ticket</button>
        </div>
      </form>
    </div>
  </div>
</div>

{# --------------------------------------------------------------------------
                                                                 NOTE MODAL
This is a generic modal based on any action whose logic requires or accepts
a note.
-------------------------------------------------------------------------- #}

<div class='modal fade' id='noteModal' tabindex='-1'>
  <div class='modal-dialog modal-dialog-centered'>
    <div class='modal-content'>
      <form class='modal-form' id='noteModalForm'>
        <div class='modal-header'>
          <h5 class='modal-title' id='noteModalTitle'>Make note</h5>
          <button type='button' class='btn-close' data-bs-dismiss='modal'></button>
        </div>
        <div class='modal-body'>
          <p id='noteModalIntro'></p>
          <p>
            <div class='form-group'>
              <label for='note' id='noteModalTextareaLabel'></label>
              <textarea class='form-control' type='text' id='noteModalTextarea' required rows='3'></textarea>
            </div>
          </p>
        </div>
        <div class='modal-footer'>
          <button type='button' class='btn btn-secondary' data-bs-dismiss='modal' id='noteModalCancel'>Cancel</button>
          <button type='submit' class='btn btn-primary' id='noteModalSubmit'>Do it</button>
        </div>
      </form>
    </div>
  </div>
</div>

{# --------------------------------------------------------------------------
                                                              HISTORY MODAL
-------------------------------------------------------------------------- #}

<div class='modal fade' id='historyModal' tabindex='-1'>
  <div class='modal-dialog modal-dialog-centered'>
    <div class='modal-content'>
      <div class='modal-header'>
        <h5 class='modal-title' id='historyModalLabel'>Burst candidate history</h5>
        <button type='button' class='btn-close' data-bs-dismiss='modal'></button>
      </div>
      <div class='modal-body' id='historyModalBody'>
      </div>
      <div class='modal-footer'>
        <button id='history_mkay' type='button' class='btn btn-primary' data-bs-dismiss='modal'>Mkay</button>
      </div>
    </div>
  </div>
</div>

{% endblock %}
